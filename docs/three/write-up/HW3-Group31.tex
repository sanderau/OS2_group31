\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}
\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}

\usepackage{geometry}
\geometry{textheight=9.5in, textwidth=7in}

% 1. Fill in these details
\def \CapstoneTeamName{		Operating Systems II}
\def \CapstoneTeamNumber{		Group 31}
\def \GroupMemberOne{			Zach Tusing}
\def \GroupMemberTwo{			Austin Sanders}
\def \GroupMemberThree{			Kevin Talik}
\def \CapstoneProjectName{		Homework 1}

			

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
 	\begin{center}
	\huge\bf{ Homework 3:} 
   
    \large\textbf{\textit{ The Crypt Keeper's Key }}\par
     
    
    
	\small{\bf CS 444 : \textit Operating Systems II, Oregon State University}\par
    \small{\bf{Group 31}}
    
    
    {\bf\textit{ Spring Term, PUT THE DATE, 2018} }
    
    
    {\small {\bf Prepared by:} \GroupMemberOne, \GroupMemberTwo, and \GroupMemberThree }
        \end{center}
    %\includegraphics{yoctoLogo.png}
    %\begin{flushright}
    %\small{Figure 69. This is a caption}
    %\end{flushright}
 		\vfill

       \pagebreak
       \section{ Purpose of this assignment }

        Security-wise, it is important to learn about the vulnerabilities of files transferred to a running operating system. If the kernel cannot verify the integrity of the host, the kernel can accept files that can be inserted into the work queue of a processor. Additionally, if the module is encrypted, the owner of the OS can not see what the block device is running.  

		This assignment had two key purposes. The first was to understand exactly how ram disk drivers work and how to encrypt the data. The second was to learn how crypto tools can be used to protect information on the computer. Files that are encrypted are described as a "Trapdoor" algorithm. It is easy to write a cypher, but difficult for a computer to decode without a key. 

	\section{ Design }
    
    	For the design of this code we decided to take a very minimalistic approach. This means only touching on the very necessities that are required for a RAM Disc device driver. This means that we are only going to use a few key functions to do what we need to do. These functions provide the following functionalities: Read/Write, Encryption, Queuing, Input and Output Control, Initialization, and Exit.

    The only parameter of the kernel module is the key used for encryption. 
    Since this key is public information, we will Asymmetric Key Generation (The RSA Algorithm) defined in \url{https://github.com/sanderau/OS2_group31/blob/master/linux-yocto-3.19.2/crypto/asymmetric_keys/ }
        
	\subsection{Read/Write}
    With the read and write operations on our Linux machine, we decided to handle the reading and writing with a simple memory allocation into ram and then handling each individual request to write by encrypting the data sent to ram with memcopy. This allowed us a simple and easy way to handle individual requests while also making sure all memory was encrypted at the time. We handled read requests by just checking the read/write bit and seeing which way memory was being copied. This time decryption will be handled after reading out since we will only be handling the buffer. This provided us with a simple execution of a read/write function and our encryption functionality built in.

    \subsection{Encryption}
    \subsubsection{ One Time Pad Encryption }
        One Time Pad Encryption \cite{khanAcademy} is a method of protecting messages by making a new, random key for every message.
        One Time Pad encryption is one of the strongest types of encryption, as there are many permutations of what a cypher could contain. 
        The strength of OTP is dependent on the integrity of the key to decrypt the cypher that is shared. 
        The problem with OTP is that when you use symmetric keys over asymmetric keys, someone in the middle can decypher messages \cite{asymmetric}.

        The RSA algorithm can provide a public key, and a private key between a host and client, protecting the integrity of a device.
        Even if an external source finds a public key, the private key can encrypt messages from the host machine, and send to other devices that have a shared RSA key.
    
    \subsection{Request Queue}
    We handled request queuing by implementing a simple request queue. This was done with the function \begin{verbatim} struct request *elv_next_request(struct request_queue *queue) \end{verbatim}. This function triggers a series of checks to see if the request in the queue identifies as a valid request for the driver. If it does validate then it will send it to the read/write function which handles data encryption and Input/Output.

    In the crypto directory, we can specify what kind of encryption we want for this module. Since we trust the process sent from the client to the VM, the kernel will run it. 
	\subsection{I/O CNTL}
	We have implemented a standard device driver I/O control function, since this is required for registering devices. This function describes and handles device information for the user.
    
	\subsection{INIT}
    Our Init function is probably the most complex. This is due to the different things that we need to initialize when setting up the driver. Our driver initializes the ram using Kmalloc. It then intializes a block queue using \begin{verbatim} struct request_queue * blk_init_queue (	request_fn_proc * rfn, spinlock_t * lock); \end{verbatim} This request queue is established and will run requests through our driver. We then establish our struct and initialize the data for our disk and then return 0. If there was an error it jumps to the bottom to execute kfrees to allow for easy and non-messy cleanup.
    
    \subsection{EXIT}
    
    This exit function is simple and consists of only five calls. The first call is \begin{verbatim}  void del_gendisk(struct gendisk *disk) \end{verbatim} which is a call to remove the disk from the active disk queue. This call cleans up all data associated with said disk and stops all future requests. The second call is to \begin{verbatim}  void put_disk(struct gendisk *disk) \end{verbatim} This call actually makes it so the disk is no longer accessible. The next call is to \begin{verbatim}  unregister_blkdev(Int, char*) \end{verbatim} This call will unregister the major number assigned to the block device. This unregisters the major:minor pairing. The fourth call cleans up the queue which will remove all nodes from the queue. The final call frees the memory allocated for the disk driver.

	
	\section{Testing}
        To test that this LKM is working properly, we will move the module into the running VM, and insert the module into the request queue (the function name is specified in the Request Queue Subsection). This is to show that a RAM driver module can be received from an outside source, and put into an I/O elevator that the kernel will run.
	\section{Command Log}

    \bibliographystyle{IEEEtran}
    \bibliography{refs}
        \end{document}
	}
	}
	}
	}
	}
	}
	}
	}
	}
